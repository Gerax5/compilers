# Semantic Analysis

---

# Architecture

## Overview

Language: Compiscript (a subset with variables, functions, classes, arrays, and control flow).

Stack: Python 3, ANTLR4 (lexer/parser), plus listeners and visitors for semantics.

Phases:

- Lexing/Parsing: CompiscriptLexer / CompiscriptParser (generated from Compiscript.g4).

- Symbol Table Construction: SymbolTableBuilder (scopes, symbols, classes, functions).

- Type Checking: TypeChecker (primitive types, arrays, classes, this, calls, indexing, etc.).

## Project Structure

```
/frontend                         # IDE
/program
  ├─ Driver.py                    # Compiler entry point
  ├─ Compiscript.g4               # ANTLR grammar
  ├─ CompiscriptLexer.py          # Generated by ANTLR
  ├─ CompiscriptParser.py         # Generated by ANTLR
  ├─ CompiscriptListener.py       # Generated by ANTLR
  ├─ CompiscriptVisitor.py        # Generated by ANTLR
  ├─ src/
  │   ├─ symbolTable/
  │   │   └─ SymbolTableBuilder.py
  │   ├─ typeChecker/
  │   │   └─ TypeChecker.py
  │   └─ utils/
  │       ├─ Errors.py            # Error recording and formatting
  │       ├─ Scope.py             # Scope, Symbol, VarSymbol, FuncSymbol, ClassSymbol
  │       └─ Types.py             # Type (Enum), ArrayType
  └─ test/
      ├─ test_symbol_table.py
      └─ test_type_checker.py

```

---

## Core Components

### `Symbol Table (src/symbolTable/SymbolTableBuilder.py)`

Responsibility: Build scopes (global, block, function, class, loop) and register symbols.

#### Manages

- enterProgram / enterBlock / enterFunctionDeclaration / enterClassDeclaration
- Variables (let), constants (const), parameters, implicit this, methods/constructors.
- Loop and switch depth counters (loop_depth, switch_depth) used later to validate break/continue
- \_type_of for primitive types (int, float, bool, string, void) and ArrayType(base, dims).
- Classes via ClassSymbol with an inner scope for fields/methods and optional superclass.

### `Types & Symbols (src/utils/Scope.py, src/utils/Types.py)`

- Types: Type enum for primitives plus ArrayType(base, dimensions).
- Symbols:
  - VarSymbol(name, ty, is_const=False)
  - FuncSymbol(name, ret, params)
  - lassSymbol(name) with its own scope, members, and optional superclass

### `Type Checking (src/typeChecker/TypeChecker.py)`

Responsibility: Walk the AST (visitor) and validate semantics:

- Declarations & assignments: compatibility via \_can_assign.
- Expressions: literals, identifiers, arithmetic/relational/equality, unary, logical.
- Arrays: homogeneous literals, IndexExpr with integer index, element type inference.
- Functions: visitFunctionDeclaration, visitReturnStatement, visitCallExpr (params/return).
- Classes: this, property access (visitPropertyAccessExpr), new, inheritance (parent members).
- Control flow: visitForStatement / visitWhileStatement / visitDoWhileStatement / visitForeachStatement, visitIfStatement, visitBreakStatement / visitContinueStatement

#### Key helpers:

- \_can_assign(dst, src) (numeric promotions, arrays, class-subclass).
- \_class_member(cls, name) (member lookup up the inheritance chain).
- \_resolve_primary_atom_type(...) for complex LHS in assignments.
- \_type_of for primitive types (int, float, bool, string, void) and ArrayType(base, dims).

Errors: report with errors.err_ctx(ctx, msg) including precise source location.

### `Errors`

- Collects diagnostics formatted like `[line x:y] ….`
- Emitted at the end by Driver.py.

---

## _Critical Flows_

### _Assignment_

- Simple: x = expr → \_apply_assignment.
- Property: obj.prop = expr → \_apply_property_assignment.
- Array: a[i] = expr → \_apply_index_assignment.

### _Calls_

- makeAdder(5), this.m(), new Dog("Rex").
- visitCallExpr validates the callee (function or class), argument arity/types, and return type.

### _Classes / Inheritance_

- ClassSymbol.superclass when declared with : Base.
- Member access resolved by \_class_member, traversing the parent chain.
- this is only valid inside a class scope.
- Inherited methods: when declaring a subclass, members from the superclass are copied into the subclass scope.
- Method overrides: if a method in the subclass has the same name as one in the superclass:
  - It replaces (overrides) the inherited method.
  - The type checker validates that the signature matches (same number of parameters, same parameter types, and same return type).
  - If the signature does not match, the type checker reports an invalid override error

### _Loops_

- Scope: Every loop (for, while, do…while, foreach) introduces its own inner scope. Variables declared in the loop header (e.g., for (let i = …)) or body are not visible outside the loop.
- continue is only valid inside a loop. It targets the innermost enclosing loop.
- break is valid inside a loop or a switch. In a loop it exits the innermost loop; inside a switch it exits the entire switch statement.
- Depth tracking: Increment loop_depth on entry to any loop and decrement on exit. Use it to validate continue and to help decide whether break is legal (see switch below).
- Switch: the switch (expr) head is visited first to obtain its type T. Each case E: expression must be compatible with T. If T is bool, cases must be boolean; otherwise a type-mismatch is reported. Increment switch_depth on entry and decrement on exit; used together with loop_depth to validate break. Statements inside each case and default are visited in order.
- Foreach: The collection expression must be an ArrayType; otherwise an error is reported. The loop variable gets the element type (for multidimensional arrays, the element is the array with one less dimensions). Increments loop_depth while visiting the body.
- Break / Continue (validation): Continue only legal inside a loop; otherwise an error. Break legal inside a loop or inside a switch; outside both is an error.
- Try / catch: Visits the try { ... } block first and then the catch (...) { ... } block if present, so inner expressions/statements are type-checked as usual.

  **Relational, Equality & Logical**

- Relational (<, >, <=, >=): boh sides most be numeric (int / float); result is bool.
- Equality (==, !=): Allowed if operands are assignable in any direction (includes numeric promotions, class-subclass, etc); result is bool.
- Logical (&&, ||): Both sides must be bool; result is bool.

  **Chained Acces (calls, indexing, properties)**

- Calls: If the reciever is a FuncSymbol, check arity and parameter types; expression type becomes the function's return type. If the receiver is a class, resolve and validate the constructure signature; expression type remains the class. Any other reciever is not invocable -> error.
- Indexing: index must be int and receiver must be an array; the resulting type is the element type.
- Property acces: Only valid on class instances; member is looked up. If the member is a function, the node carries a FuncSymbol so a subsequent call can be type-checked; if it's a field, the type is that field's type.

  **Assignments (LHS with suffixes)**

- Property assignemmt (obj.prop = expr): Checks that prop exists and the RHS is assignable to its type.
- Indexed assignment (arr[i] = expr): Checks arr is array, i:int, and RHS compatible with the element type.
- Call as LHS: Invalid (cannot assign to the result of a call).

  **Constructurs (new)**

- Class resolution: If the identifier after new must resolve to a class type.
- Signature check: If a constructur exists, arity and each argument type must match its parameter type; otherwise an error is reported (including the case of passing args when no constructur exists).
- Result: The expression type is the class itself.

  **Conditional (?:)**

- Condition: Must be bool.
- Type resolution:

  - If both branches have the same type → that type.
  - For arrays: require same dimensions and unify numeric base types if possible.
  - For numeric primitives: int/float unify to float.
  - Otherwise → incompatible, result null with a diagnostic.

  **Array Literals**

- Empty arrays: type cannot be inferred; require an explicit annotation (e.g., int[]).
- Homogeneity:
  - Mixing scalar and subarray → error.
  - All subarrays must have the same dimensions.
  - Base types are unified (e.g., int + float → float); otherwise error.
- Resulting type: ArrayType(base, dims) inferred from elements.
