# Semantic Analysis

---

# Architecture

## Overview

Language: Compiscript (a subset with variables, functions, classes, arrays, and control flow).

Stack: Python 3, ANTLR4 (lexer/parser), plus listeners and visitors for semantics.

Phases:

- Lexing/Parsing: CompiscriptLexer / CompiscriptParser (generated from Compiscript.g4).

- Symbol Table Construction: SymbolTableBuilder (scopes, symbols, classes, functions).

- Type Checking: TypeChecker (primitive types, arrays, classes, this, calls, indexing, etc.).

## Project Structure

```
/program
  ├─ Driver.py                    # Compiler entry point
  ├─ Compiscript.g4               # ANTLR grammar
  ├─ CompiscriptLexer.py          # Generated by ANTLR
  ├─ CompiscriptParser.py         # Generated by ANTLR
  ├─ CompiscriptListener.py       # Generated by ANTLR
  ├─ CompiscriptVisitor.py        # Generated by ANTLR
  ├─ src/
  │   ├─ symbolTable/
  │   │   └─ SymbolTableBuilder.py
  │   ├─ typeChecker/
  │   │   └─ TypeChecker.py
  │   └─ utils/
  │       ├─ Errors.py            # Error recording and formatting
  │       ├─ Scope.py             # Scope, Symbol, VarSymbol, FuncSymbol, ClassSymbol
  │       └─ Types.py             # Type (Enum), ArrayType
  └─ test/
      ├─ test_symbol_table.py
      └─ test_type_checker.py

```

---

## Core Components

### `Symbol Table (src/symbolTable/SymbolTableBuilder.py)`

Responsibility: Build scopes (global, block, function, class, loop) and register symbols.

#### Manages

- enterProgram / enterBlock / enterFunctionDeclaration / enterClassDeclaration
- Variables (let), constants (const), parameters, implicit this, methods/constructors.
- Loop and switch depth counters (loop_depth, switch_depth) used later to validate break/continue
- \_type_of for primitive types (int, float, bool, string, void) and ArrayType(base, dims).
- Classes via ClassSymbol with an inner scope for fields/methods and optional superclass.

### `Types & Symbols (src/utils/Scope.py, src/utils/Types.py)`

- Types: Type enum for primitives plus ArrayType(base, dimensions).
- Symbols:
  - VarSymbol(name, ty, is_const=False)
  - FuncSymbol(name, ret, params)
  - lassSymbol(name) with its own scope, members, and optional superclass

### `Type Checking (src/typeChecker/TypeChecker.py)`

Responsibility: Walk the AST (visitor) and validate semantics:

- Declarations & assignments: compatibility via \_can_assign.
- Expressions: literals, identifiers, arithmetic/relational/equality, unary, logical.
- Arrays: homogeneous literals, IndexExpr with integer index, element type inference.
- Functions: visitFunctionDeclaration, visitReturnStatement, visitCallExpr (params/return).
- Classes: this, property access (visitPropertyAccessExpr), new, inheritance (parent members).
- Control flow: visitForStatement / visitWhileStatement / visitDoWhileStatement / visitForeachStatement, visitIfStatement, visitBreakStatement / visitContinueStatement

#### Key helpers:

- \_can_assign(dst, src) (numeric promotions, arrays, class-subclass).
- \_class_member(cls, name) (member lookup up the inheritance chain).
- \_resolve_primary_atom_type(...) for complex LHS in assignments.
- \_type_of for primitive types (int, float, bool, string, void) and ArrayType(base, dims).

Errors: report with errors.err_ctx(ctx, msg) including precise source location.

### `Errors`

- Collects diagnostics formatted like `[line x:y] ….`
- Emitted at the end by Driver.py.

---

## _Critical Flows_

### _Assignment_

- Simple: x = expr → \_apply_assignment.
- Property: obj.prop = expr → \_apply_property_assignment.
- Array: a[i] = expr → \_apply_index_assignment.

### _Calls_

- makeAdder(5), this.m(), new Dog("Rex").
- visitCallExpr validates the callee (function or class), argument arity/types, and return type.

### _Classes / Inheritance_

- ClassSymbol.superclass when declared with : Base.
- Member access resolved by \_class_member, traversing the parent chain.
- this is only valid inside a class scope.

### _Loops_

- Scope: Every loop (for, while, do…while, foreach) introduces its own inner scope. Variables declared in the loop header (e.g., for (let i = …)) or body are not visible outside the loop.
- continue is only valid inside a loop. It targets the innermost enclosing loop.
- break is valid inside a loop or a switch. In a loop it exits the innermost loop; inside a switch it exits the entire switch statement.
- Depth tracking: Increment loop_depth on entry to any loop and decrement on exit. Use it to validate continue and to help decide whether break is legal (see switch below).
